% $Header: svn://192.168.32.71/trunk/AMIGO_R2012_cvodes/add_DynamicOpt/Preprocessor/AMIGO_gen_multidocost.m 770 2013-08-06 09:41:45Z attila $
  function [inputs,results]=AMIGO_gen_multidocost(inputs,results,reopt,ireopt);  
% AMIGO_gen_multidocost: generates cost function and constraints for multiobjective OD
%
%******************************************************************************
% AMIGO Advanced Model Identification using Global Optimization               %
% Code development:     Eva Balsa-Canto                                       %
% Address:              Process Engineering Group, IIM-CSIC                   %
%                       C/Eduardo Cabello 6, 36208, Vigo-Spain                %
% e-mail:               ebalsa@iim.csic.es                                    %
% Copyright:            CSIC, Spanish National Research Council               %
%**************************************************************************
%****
%
%*****************************************************************************%
%                                                                             %
%  AMIGO_gen_multidocost: generates cost function and constraints for         %
%                    multiobjective OD for the different optimizers           %
%                    It should be noted that different solvers will require   %
%                    different information. Particular cases for the
%                    available%
%                    optimizers are included here                             %
%*****************************************************************************%
current_dir=pwd;


        inputs.pathd.problem_folder_path=strcat(inputs.pathd.results_path,filesep,inputs.pathd.results_folder);
        if isdir(inputs.pathd.problem_folder_path)==0  
        mkdir(strcat(inputs.pathd.AMIGO_path,filesep,inputs.pathd.problem_folder_path));
        end
        genpath(inputs.pathd.problem_folder_path);  
        inputs.pathd.DO_function=strcat('AMIGO_DOcost_',inputs.pathd.short_name);
        inputs.pathd.DO_constraints=strcat('AMIGO_DOconst_',inputs.pathd.short_name);
        inputs.pathd.DO_file=strcat(inputs.pathd.AMIGO_path,filesep,inputs.pathd.problem_folder_path,filesep,inputs.pathd.DO_function,'.m');
        inputs.pathd.DO_constfile=strcat(inputs.pathd.AMIGO_path,filesep,inputs.pathd.problem_folder_path,filesep,inputs.pathd.DO_constraints,'.m');
        
%
% Generates MATLAB code with the objective function + constraints supplied by user
% 
% 

    fid2=fopen(inputs.pathd.DO_file,'w');
    fid3=fopen(inputs.pathd.DO_constfile,'w');


    fprintf(fid2,'function [f,g,h]=%s(od,inputs,results,privstruct)\n',inputs.pathd.DO_function);
    fprintf(fid2,'%%\n%%Code generated by AMIGO to compute cost function & constraints\n%%\n');
    fprintf(fid2','\n%% Solves system dynamics \n\n');
    

    fprintf(fid2, '\t y = AMIGO_DOcost(od,inputs,results);\n');
    
    
    % DECLARING STATES TO COMPUTE COST FUNCTION
        if numel(inputs.model.st_names)>0
            for i=1:inputs.model.n_st
            fprintf(fid2,'\t%s=y(end,%u);\n',inputs.model.st_names(i,:),i);
            end
        end

    % DECLARES CONTROL VARIABLES
        if numel(inputs.model.stimulus_names)>0
            switch inputs.DOsol.tf_type
                case 'od'
                  switch inputs.exps.u_interp{1}  
                  case 'stepf'
                  ncount=1;
                  otherwise
                  ncount=0;
                  end
                otherwise
            ncount=0;
            end
            
            for iu=1:inputs.model.n_stimulus
                fprintf(fid2,'\t%s=[',inputs.model.stimulus_names(iu,:));
        
                switch inputs.exps.u_interp{1}  
                    case {'stepf','step'}
                    for istep=1:inputs.DOsol.n_steps
                    fprintf(fid2,'\t od(%u)',istep+ncount);
                    ncount2=istep+ncount;
                    end
                    fprintf(fid2,'\t];\n');
                    ncount=ncount2;
        
                    case {'linearf','linear'}
                    for ilinear=1:inputs.DOsol.n_linear
                    fprintf(fid2,'\t od(%u)',ilinear+ncount);
                    ncount2=ilinear+ncount;
                    end
                    fprintf(fid2,'\t];\n');
                    ncount=ncount2;
                end
        
            end % iu=1:inputs.model.n_stimulus
        end % if numel(inputs.model.stimulus_names)>0
    
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % MULTIOBJECTIVE, COST FUNCTIONS
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
       
        switch inputs.nlpsol.nlpsolver
            case'monlot'
            fprintf(fid2,'\n%% Definition of cost functions to be maximized\n'); 
        
            switch inputs.DOsol.DOcost_type
            case 'min'
            for icost=1:inputs.DOsol.N_DOcost    
            fprintf(fid2,'\tf(%u,:) = -%s;\n',icost,inputs.DOsol.DOcost{icost}); 
            end
            case 'max'
            for icost=1:inputs.DOsol.N_DOcost    
            fprintf(fid2,'\tf(%u,:) = %s;\n',icost,inputs.DOsol.DOcost{icost}); 
            end        
            end
          
            case 'nsga2'
                
          
            fprintf(fid2,'\n%% Definition of cost functions to be minimized\n'); 
        
            switch inputs.DOsol.DOcost_type
            case 'min'
            for icost=1:inputs.DOsol.N_DOcost    
            fprintf(fid2,'\tf(%u) = %s;\n',icost,inputs.DOsol.DOcost{icost}); 
            end
            case 'max'
            for icost=1:inputs.DOsol.N_DOcost    
            fprintf(fid2,'\tf(%u) = -%s;\n',icost,inputs.DOsol.DOcost{icost}); 
            end        
            end
            
            
            case 'wsm'
                
            switch inputs.DOsol.DOcost_type
            case 'min'    
            fprintf(fid2,'\tf='); 
            for icost=1:inputs.DOsol.N_DOcost-1
            fprintf(fid2,'%e*%s+',inputs.DOsol.wsm(icost),inputs.DOsol.DOcost{icost});   
            end    
            fprintf(fid2,'%e*%s;\n',inputs.DOsol.wsm(inputs.DOsol.N_DOcost),inputs.DOsol.DOcost{inputs.DOsol.N_DOcost});   
            for icost=1:inputs.DOsol.N_DOcost
            fprintf(fid2,'h(%u)=%s;\n',icost,inputs.DOsol.DOcost{icost});   
            end   
            case 'max'
            fprintf(fid2,'\tf='); 
            for icost=1:inputs.DOsol.N_DOcost-1
            fprintf(fid2,'-%e*%s-',inputs.DOsol.wsm(icost),inputs.DOsol.DOcost{icost});   
            end    
            fprintf(fid2,'%e*%s;\n',inputs.DOsol.wsm(inputs.DOsol.N_DOcost),inputs.DOsol.DOcost{inputs.DOsol.N_DOcost});  
            end   
            for icost=1:inputs.DOsol.N_DOcost
            fprintf(fid2,'h(%u)=%s;\n',icost,inputs.DOsol.DOcost{icost});   
            end           
            
        end  %switch inputs.nlpsol.nlpsolver  
        

    
    
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % CONSTRAINTS: END-POINT EQUALITY
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
       
    % MOST METHODS HANDLE INEQUALITY CONSTRAINTS THUS WE WILL TRANSFORM 
    % EQUALITY CONSTRAINTS INTO INEQUALITIES WITH A TOLERANCE INTRODUCED
    % BY USER.
    
    fprintf(fid2,'\n%% Definition of constraints\n');
    

        
    if inputs.DOsol.n_const_eq_tf>0 
    fprintf(fid2,'\n%% End-point equality constraints (transformed into inequalities)\n');    

    
    switch inputs.nlpsol.nlpsolver
   
        case'wsm'
    
        for icons=1:inputs.DOsol.n_const_eq_tf 
        fprintf(fid2,'\tg(%u) = abs(%s)-%f;\n',icons,inputs.DOsol.const_eq_tf(icons,:),inputs.DOsol.eq_const_max_viol); 
        end 
            
            switch inputs.nlpsol.global_solver
            case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');   
            fprintf(fid2,'\nswitch privstruct.global_solver\n');  
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1:inputs.DOsol.n_const_eq_tf  
            fprintf(fid2,'\t if abs(g(%u)) >%f\n',icons,inputs.DOsol.eq_const_max_viol); 
            fprintf(fid2,'\t f=inf;\n');
            fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');    
            end    
            fprintf(fid3,'problem.neq=0;\n');

            
         case'monlot'
            for icons=1:inputs.DOsol.n_const_eq_tf 
            fprintf(fid2,'\tg(%u) =-abs(%s)+%f;\n',icons,inputs.DOsol.const_eq_tf(icons,:),inputs.DOsol.eq_const_max_viol); 
            end  
            
         case'nsga2'
            for icons=1:inputs.DOsol.n_const_eq_tf     
            fprintf(fid2,'\tcons(%u) =abs(%s)-%f;\n',icons,inputs.DOsol.const_eq_tf(icons,:),inputs.DOsol.eq_const_max_viol); 
            fprintf(fid2,'\t if cons(%u)>0\n',icons);
            fprintf(fid2,'\t g(%u)=abs(cons(%u));\n',icons,icons);
            fprintf(fid2,'\t else\n');
            fprintf(fid2,'\t g(%u)=0;\n',icons);  
            fprintf(fid2,'\t end %% end of if cons\n');
            end   
            
                
    end % switch inputs.nlpsol.nlpsolver
            
            
    
    end %if inputs.DOsol.n_const_eq_tf>0 
    
    
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % CONSTRAINTS: END-POINT INEQUALITY
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       
    
    if inputs.DOsol.n_const_ineq_tf>0
    
    fprintf(fid2,'\n%% End-point inequality constraints\n');    
    
 
    switch inputs.nlpsol.nlpsolver
   
        case'wsm'
    
        for icons=1:inputs.DOsol.n_const_ineq_tf  
        fprintf(fid2,'\tg(%u) = %s;\n',icons+inputs.DOsol.n_const_eq_tf,inputs.DOsol.const_ineq_tf(icons,:)); 
        end
        for icons=1:inputs.DOsol.n_const_eq_tf
        fprintf(fid3,'problem.c_L(1,%u)=-%f;\n',icons,inputs.DOsol.eq_const_max_viol);
        fprintf(fid3,'problem.c_U(1,%u)=%f;\n',icons,inputs.DOsol.eq_const_max_viol);
        end    
        for icons=1:inputs.DOsol.n_const_ineq_tf
        fprintf(fid3,'problem.c_L(1,%u)=-inf;\n',icons+inputs.DOsol.n_const_eq_tf);
        fprintf(fid3,'problem.c_U(1,%u)=%f;\n',icons+inputs.DOsol.n_const_eq_tf,inputs.DOsol.ineq_const_max_viol);
        end
     
      
            % WHEN USING DE
 
            switch inputs.nlpsol.global_solver
            case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');   
            fprintf(fid2,'\nswitch inputs.nlpsol.global_solver\n');  
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1 :inputs.DOsol.n_const_ineq_tf  
            fprintf(fid2,'\t if g(%u) >%f\n',icons+inputs.DOsol.n_const_eq_tf,inputs.DOsol.ineq_const_max_viol); 
            fprintf(fid2,'\t f=inf;\n');
            fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
            end 
       
        case 'monlot'
        for icons=1:inputs.DOsol.n_const_ineq_tf  
        fprintf(fid2,'\tg(%u) = -%s;\n',icons+inputs.DOsol.n_const_eq_tf,inputs.DOsol.const_ineq_tf(icons,:)); 
        end
        
        case 'nsga2'
        for icons=1:inputs.DOsol.n_const_ineq_tf  
        fprintf(fid2,'\tcons(%u) = %s;\n',icons+inputs.DOsol.n_const_eq_tf,inputs.DOsol.const_ineq_tf(icons,:));
        fprintf(fid2,'\t if cons(%u)>0\n',icons);
        fprintf(fid2,'\t g(%u)=abs(cons(%u));\n',icons,icons);
        fprintf(fid2,'\t else\n');
        fprintf(fid2,'\t g(%u)=0;\n',icons);       
        fprintf(fid2,'\t end %% end of if cons\n');
        end    
        
        
    end % switch inputs.nlpsol.nlpsolver
    
    end % if inputs.DOsol.n_const_ineq_tf>0
    
    if inputs.DOsol.n_const_eq_tf==0 && inputs.DOsol.n_const_ineq_tf==0
    fprintf(fid2,'\t g(1)=0;\n');
    end


 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % CONSTRAINTS: CONTROL VARIABLES
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      
 nconstraints=inputs.DOsol.n_const_eq_tf+inputs.DOsol.n_const_ineq_tf;
 
   if inputs.DOsol.n_control_const>0
       
       switch inputs.nlpsol.nlpsolver
   
        case'wsm' 
       
       
        switch inputs.exps.u_interp{1}  
        case {'stepf','step'}    
       
        for icons=1:inputs.DOsol.n_control_const 
        fprintf(fid2,'\t const_vector(%u,:) =%s;\n',icons,inputs.DOsol.control_const(icons,:)); 
        ncount=0;
        for istep=1:inputs.DOsol.n_steps
        fprintf(fid2,'\t g(%u) =const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);      
        end 
        ncount=ncount+inputs.DOsol.n_steps;
        end
 
        for icons=1:inputs.DOsol.n_control_const* inputs.DOsol.n_steps
            fprintf(fid3,'problem.c_L(1,%u)=-inf;\n',icons+nconstraints);
            fprintf(fid3,'problem.c_U(1,%u)=%f;\n',icons+nconstraints,inputs.DOsol.control_const_max_viol);
        end 

            % WHEN USING DE
               
            switch inputs.nlpsol.global_solver
            case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');   
            fprintf(fid2,'\nswitch inputs.nlpsol.global_solver\n');  
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1 :inputs.DOsol.n_control_const* inputs.DOsol.n_steps
            fprintf(fid2,'\t if g(%u) >%f\n',icons+nconstraints,inputs.DOsol.control_const_max_viol); 
            fprintf(fid2,'\t f=inf;\n');
            fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
            end
    
        
        case 'linear'
        
            for icons=1:inputs.DOsol.n_control_const 
            fprintf(fid2,'\t const_vector(%u,:) =%s;\n',icons,inputs.DOsol.control_const(icons,:)); 
            ncount=0;
            for istep=1:inputs.DOsol.n_linear
            fprintf(fid2,'\t g(%u) =const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);      
            end 
            ncount=ncount+inputs.DOsol.n_linear;
            end
   
            for icons=1:inputs.DOsol.n_control_const* inputs.DOsol.n_linear
            fprintf(fid3,'problem.c_L(1,%u)=-inf;\n',icons+nconstraints);
            fprintf(fid3,'problem.c_U(1,%u)=%f;\n',icons+nconstraints,inputs.DOsol.control_const_max_viol);
            end 
         
            
         
        switch inputs.nlpsol.global_solver
        case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');   
            fprintf(fid2,'\n switch inputs.nlpsol.global_solver\n');  
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1 :inputs.DOsol.n_control_const* inputs.DOsol.n_linear
            fprintf(fid2,'\t if g(%u) >%f\n',icons+nconstraints,inputs.DOsol.control_const_max_viol); 
            fprintf(fid2,'\t f=inf;\n');
            fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
        end
               
    end %    switch inputs.exps.u_interp{1}    
    
     case'monlot'
        switch inputs.exps.u_interp{1}  
        case {'stepf','step'}    
       
        for icons=1:inputs.DOsol.n_control_const 
        fprintf(fid2,'\t const_vector(%u,:) =-%s;\n',icons,inputs.DOsol.control_const(icons,:)); 
        ncount=0;
        for istep=1:inputs.DOsol.n_steps
        fprintf(fid2,'\t g(%u) =const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);      
        end 
        ncount=ncount+inputs.DOsol.n_steps;
        end
            
        
        case 'linear'
        
        for icons=1:inputs.DOsol.n_control_const 
        fprintf(fid2,'\t const_vector(%u,:) =-%s;\n',icons,inputs.DOsol.control_const(icons,:)); 
        ncount=0;
        for istep=1:inputs.DOsol.n_linear
        fprintf(fid2,'\t g(%u) =const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);      
        end 
        ncount=ncount+inputs.DOsol.n_linear;
        end
   
               
       end %    switch inputs.exps.u_interp{1}   
       
       
   case'nsga2'
        switch inputs.exps.u_interp{1}  
        case {'stepf','step'}    
       
        for icons=1:inputs.DOsol.n_control_const 
        fprintf(fid2,'\t const_vector(%u,:) =-%s;\n',icons,inputs.DOsol.control_const(icons,:)); 
        ncount=0;
        for istep=1:inputs.DOsol.n_steps
        fprintf(fid2,'\t if const_vector(%u,%u)>0\n',icons,istep);    
        fprintf(fid2,'\t g(%u)=const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);  
        fprintf(fid2,'\t else\n');
        fprintf(fid2,'\t g(%u)=0;\n',istep+ncount+nconstraints);  
        fprintf(fid2,'\t end;\n');      
        end 
        ncount=ncount+inputs.DOsol.n_steps;
        end
            
        
        case 'linear'
        
        for icons=1:inputs.DOsol.n_control_const 
        fprintf(fid2,'\t const_vector(%u,:) =-%s;\n',icons,inputs.DOsol.control_const(icons,:)); 
        ncount=0;
        for istep=1:inputs.DOsol.n_linear
        fprintf(fid2,'\t if const_vector(%u,%u)>0\n',icons,istep);    
        fprintf(fid2,'\t g(%u)=const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);  
        fprintf(fid2,'\t else\n');
        fprintf(fid2,'\t g(%u)=0;\n',istep+ncount+nconstraints);  
        fprintf(fid2,'\t end;\n');         
        end 
        ncount=ncount+inputs.DOsol.n_linear;
        end
   
               
       end %    switch inputs.exps.u_interp{1}  
       
       
       
         
   end %  switch inputs.nlpsol.nlpsolver     
    
    
        
   end % if inputs.DOsol.n_control_const>0
 
 
    results.nlpsol.ntotalconstraints=nconstraints+ncount;
 


    fprintf(fid2,'\n\nreturn');
    fclose(fid2);
    fclose(fid3);
%     fprintf(1,'\n\nThe following files have been created:\n');
%     fprintf(1,'%s\n', inputs.pathd.DO_file);
%     fprintf(1,'%s\n', inputs.pathd.DO_constfile);
  
    addpath(genpath(strcat(inputs.pathd.AMIGO_path,filesep,'Results')));


    
return

  
        