% $Header: svn://192.168.32.71/trunk/AMIGO_R2012_cvodes/add_DynamicOpt/Preprocessor/AMIGO_gen_ODcost.m 770 2013-08-06 09:41:45Z attila $
function [inputs,results]=AMIGO_gen_IOCcost(inputs,reopt,ireopt)
% AMIGO_gen_ODcost: generates cost function and constraints for OD
%
%******************************************************************************
% AMIGO2: dynamic modeling, optimization and control of biological systems    % 
% Code development:     Eva Balsa-Canto                                       %
% Address:              Process Engineering Group, IIM-CSIC
% %
%                       C/Eduardo Cabello 6, 36208, Vigo-Spain                %
% e-mail:               ebalsa@iim.csic.es                                    %
% Copyright:            CSIC, Spanish National Research Council               %
%**************************************************************************
%****
%
%*****************************************************************************%
%                                                                             %
%  AMIGO_gen_ODcost: generates cost function and constraints for OD           %
%                    for the different optimizers                             %
%                    It should be noted that different solvers will require   %
%                    different information. Particular cases for the available%
%                    optimizers are included here                             %
%*****************************************************************************%


%Define paths & create folders

inputs.pathd.problem_folder_path=fullfile(inputs.pathd.results_path,inputs.pathd.results_folder);
    
if isdir(inputs.pathd.problem_folder_path)==0
   mkdir(fullfile(inputs.pathd.AMIGO_path,inputs.pathd.problem_folder_path));
end

addpath(fullfile(inputs.pathd.AMIGO_path,inputs.pathd.problem_folder_path));

switch reopt
    
    case 'off'             
        inputs.pathd.ioc_function=['AMIGO_IOCcost_',inputs.pathd.short_name];
        inputs.pathd.ioc_constraints=['AMIGO_IOCconst_',inputs.pathd.short_name];   
    case 'on'
        inputs.pathd.ioc_function=['AMIGO_IOCcost_reopt',num2str(ireopt),'_',inputs.pathd.short_name];
        inputs.pathd.ioc_constraints=['AMIGO_IOCconst_reopt',num2str(ireopt),'_',inputs.pathd.short_name];
           
end

inputs.pathd.ioc_file=fullfile(inputs.pathd.AMIGO_path,inputs.pathd.problem_folder_path,[inputs.pathd.ioc_function '.m']);
inputs.pathd.ioc_constfile=fullfile(inputs.pathd.AMIGO_path,inputs.pathd.problem_folder_path,[inputs.pathd.ioc_constraints '.m']);



%
% Generates MATLAB code with the objective function + constraints supplied by user
%
%


fid2=fopen(inputs.pathd.ioc_file,'w');
fid3=fopen(inputs.pathd.ioc_constfile,'w');

fprintf(fid2,'function [f,h,g]=%s(ido,inputs,results,privstruct)\n',inputs.pathd.ioc_function);
fprintf(fid2,'%%\n%%Code generated by AMIGO to compute cost function & constraints\n%%\n');
fprintf(fid2','\n%% Solves system dynamics \n\n');


fprintf(fid2, '\t [y,f,g] = AMIGO_IOCcost(ido,inputs,results);\n');


fprintf(fid2,'\t if isinf(f)\n \t h(1)=0; \n \t return;\n \t else\n');

% DECLARING STATES TO COMPUTE COST FUNCTION
if numel(inputs.model.st_names)>0
    for iexp=1:inputs.exps.n_exp
    for i=1:inputs.model.n_st
        fprintf(fid2,'\t%s{%u}=y{%u}(end,%u);\n',inputs.model.st_names(i,:),iexp,iexp,i);
    end
    end
end

% DECLARES CONTROL VARIABLES


if numel(inputs.model.stimulus_names)>0
    switch inputs.IOCsol.tf_type
        case 'od'
            switch inputs.exps.u_interp
                case 'stepf'
                    ncount=1;
                otherwise
                    ncount=0;
            end
        otherwise
            ncount=0;
    end
    
    ncount=ncount+inputs.IOCsol.n_par;
    
    
    for iexp=1:inputs.exps.n_exp
    for iu=1:inputs.model.n_stimulus
        fprintf(fid2,'\t%s{%u}=[',inputs.model.stimulus_names(iu,:),iexp);
        
  
        switch inputs.IOCsol.u_interp
                case {'sustained'}
                inputs.IOCsol.n_steps{iexp}=1;
                for istep=1:inputs.IOCsol.n_steps{iexp}
                    fprintf(fid2,'\t ido(%u)',istep+ncount);
                    ncount2=istep+ncount;
                end
                fprintf(fid2,'\t];\n');
                ncount=ncount2;
            case {'stepf','step'}
                for istep=1:inputs.IOCsol.n_steps{iexp}
                    fprintf(fid2,'\t ido(%u)',istep+ncount);
                    ncount2=istep+ncount;
                end
                fprintf(fid2,'\t];\n');
                ncount=ncount2;   
                
            case {'pulse-down'}
                for istep=1:2*inputs.IOCsol.n_pulses{iexp}-1
                    fprintf(fid2,'\t ido(%u)',istep+ncount);
                    ncount2=istep+ncount;
                end
                fprintf(fid2,'\t];\n');
                ncount=ncount2;
            
            case {'pulse-up'}
                for istep=1:2*inputs.IOCsol.n_pulses{iexp}
                    fprintf(fid2,'\t ido(%u)',istep+ncount);
                    ncount2=istep+ncount;
                end
                fprintf(fid2,'\t];\n');
                ncount=ncount2;
                
            case {'linearf','linear'}
                for ilinear=1:inputs.IOCsol.n_linear{iexp}
                    fprintf(fid2,'\t ido(%u)',ilinear+ncount);
                    ncount2=ilinear+ncount;
                end
                fprintf(fid2,'\t];\n');
                ncount=ncount2;
        end
        
    end % iu=1:inputs.model.n_stimulus
    end %for iexp=1:inputs.exps.n_exp
end % if numel(inputs.model.stimulus_names)>0

fprintf(fid2,'\t end\n\n');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONSTRAINTS: END-POINT EQUALITY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% MOST METHODS HANDLE INEQUALITY CONSTRAINTS THUS WE WILL TRANSFORM
% EQUALITY CONSTRAINTS INTO INEQUALITIES WITH A TOLERANCE INTRODUCED
% BY USER.



% UPDATE FOR MULTI-EXPERIMENT

if inputs.IOCsol.n_const_eq_tf>0
    fprintf(fid2,'\n%% End-point equality constraints (transformed into inequalities)\n');
      
    % FOR DE WE NEED TO IMPLEMENT THE DEATH PENALTY
    switch inputs.nlpsol.nlpsolver
        case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');
            fprintf(fid2,'\nswitch inputs.nlpsol.nlpsolver\n');
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1:inputs.IOCsol.n_const_eq_tf
                fprintf(fid2,'\t if abs(h(%u)) >%e\n',icons,inputs.IOCsol.eq_const_max_viol);
                fprintf(fid2,'\t f=inf;\n');
                fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
            
        case 'sres'
            for icons=1:inputs.IOCsol.n_const_eq_tf
                fprintf(fid2,'\th(%u) = abs(%s)-%e;\n',icons,inputs.IOCsol.const_eq_tf(icons,:),inputs.IOCsol.eq_const_max_viol);
            end
        case {'ssm','ess','eSS','fssm','local','multistart','hybrid','wsm'}
            fprintf(fid3,'problem.neq=0;\n');
            for icons=1:inputs.IOCsol.n_const_eq_tf
                fprintf(fid2,'\th(%u) = abs(%s);\n',icons,inputs.IOCsol.const_eq_tf(icons,:));
            end
            
            %fprintf(fid3,'problem.neq=%u;\n',inputs.IOCsol.n_const_eq_tf);
    end
    
    % FOR THE HYBRIDS WITH DE WE NEED TO IMPLEMENT THE DEATH PENALTY
    
    switch inputs.nlpsol.global_solver
        case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');
            fprintf(fid2,'\nswitch privstruct.global_solver\n');
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1:inputs.IOCsol.n_const_eq_tf
                fprintf(fid2,'\t if abs(h(%u)) >%e\n',icons,inputs.IOCsol.eq_const_max_viol);
                fprintf(fid2,'\t f=inf;\n');
                fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
    end
    fprintf(fid3,'problem.neq=0;\n');
    
    
end %if inputs.IOCsol.n_const_eq_tf>0


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONSTRAINTS: END-POINT INEQUALITY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if inputs.IOCsol.n_const_ineq_tf>0 || inputs.IOCsol.n_const_eq_tf>0
    fprintf(fid2,'\n%% End-point inequality constraints\n');
    for icons=1:inputs.IOCsol.n_const_ineq_tf
        fprintf(fid2,'\th(%u) = %s;\n',icons+inputs.IOCsol.n_const_eq_tf,inputs.IOCsol.const_ineq_tf(icons,:));
    end
    
    
    % FOR DE WE NEED TO IMPLEMENT THE DEATH PENALTY
    switch inputs.nlpsol.nlpsolver
        case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');
            fprintf(fid2,'\nswitch inputs.nlpsol.nlpsolver\n');
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1 :inputs.IOCsol.n_const_ineq_tf
                fprintf(fid2,'\t if h(%u) >%e\n',icons+inputs.IOCsol.n_const_eq_tf,inputs.IOCsol.ineq_const_max_viol);
                fprintf(fid2,'\t f=inf;\n');
                fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
            
        case {'ssm','ess','eSS','fssm','local','multistart','hybrid','wsm'}
            for icons=1:inputs.IOCsol.n_const_eq_tf
                fprintf(fid3,'problem.c_L(1,%u)=-%e;\n',icons,inputs.IOCsol.eq_const_max_viol);
                fprintf(fid3,'problem.c_U(1,%u)=%e;\n',icons,inputs.IOCsol.eq_const_max_viol);
            end
            for icons=1:inputs.IOCsol.n_const_ineq_tf
                fprintf(fid3,'problem.c_L(1,%u)=-inf;\n',icons+inputs.IOCsol.n_const_eq_tf);
                fprintf(fid3,'problem.c_U(1,%u)=%e;\n',icons+inputs.IOCsol.n_const_eq_tf,inputs.IOCsol.ineq_const_max_viol);
            end
    end
    
    
    % FOR HYBRIDS WITH DE WE NEED TO IMPLEMENT THE DEATH PENALTY
    
    switch inputs.nlpsol.global_solver
        case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');
            fprintf(fid2,'\nswitch inputs.nlpsol.global_solver\n');
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1 :inputs.IOCsol.n_const_ineq_tf
                fprintf(fid2,'\t if h(%u) >%e\n',icons+inputs.IOCsol.n_const_eq_tf,inputs.IOCsol.ineq_const_max_viol);
                fprintf(fid2,'\t f=inf;\n');
                fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
    end
    
end

if inputs.IOCsol.n_const_eq_tf==0 && inputs.IOCsol.n_const_ineq_tf==0
    fprintf(fid2,'\t h(1)=0;\n');
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONSTRAINTS: CONTROL VARIABLES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nconstraints=inputs.IOCsol.n_const_eq_tf+inputs.IOCsol.n_const_ineq_tf;

if inputs.IOCsol.n_control_const>0
    
    
    switch inputs.exps.u_interp{1}
        case {'stepf','step'}
             ncount=0;
            for icons=1:inputs.IOCsol.n_control_const
                fprintf(fid2,'\t const_vector(%u,:) =%s;\n',icons,inputs.IOCsol.control_const(icons,:));
                 for istep=1:inputs.IOCsol.n_steps{iexp}
                    fprintf(fid2,'\t h(%u) =const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);
                end
                ncount=ncount+inputs.IOCsol.n_steps{iexp};
            end
            
            switch inputs.nlpsol.nlpsolver
                
                % FOR DE WE NEED TO IMPLEMENT THE DEATH PENALTY
                case 'de'
                    fprintf(fid2,'\n%% Death penalty for DE\n');
                    fprintf(fid2,'\nswitch inputs.nlpsol.nlpsolver\n');
                    fprintf(fid2,'\ncase ''de''\n');
                    for icons=1 :inputs.IOCsol.n_control_const* inputs.IOCsol.n_steps
                        fprintf(fid2,'\t if h(%u) >%e\n',icons+nconstraints,inputs.IOCsol.control_const_max_viol);
                        fprintf(fid2,'\t f=inf;\n');
                        fprintf(fid2,'\t end;\n');
                    end
                    fprintf(fid2,'\t end;\n');
                    
                    
                    
                case {'ssm','ess','eSS','fssm','local','multistart','hybrid','wsm'}
                    
                    for icons=1:inputs.IOCsol.n_control_const*inputs.IOCsol.n_steps{iexp}
                        fprintf(fid3,'problem.c_L(1,%u)=-inf;\n',icons+nconstraints);
                        fprintf(fid3,'problem.c_U(1,%u)=%e;\n',icons+nconstraints,inputs.IOCsol.control_const_max_viol);
                    end
                    
            end %switch inputs.nlpsol.nlpsolver
            
            
            switch inputs.nlpsol.global_solver
                case 'de'
                    fprintf(fid2,'\n%% Death penalty for DE\n');
                    fprintf(fid2,'\nswitch inputs.nlpsol.global_solver\n');
                    fprintf(fid2,'\ncase ''de''\n');
                    for icons=1 :inputs.IOCsol.n_control_const* inputs.IOCsol.n_steps
                        fprintf(fid2,'\t if h(%u) >%e\n',icons+nconstraints,inputs.IOCsol.control_const_max_viol);
                        fprintf(fid2,'\t f=inf;\n');
                        fprintf(fid2,'\t end;\n');
                    end
                    fprintf(fid2,'\t end;\n');
            end
            
            
        case {'linearf','linear'}
             ncount=0;
            for icons=1:inputs.IOCsol.n_control_const
                fprintf(fid2,'\t const_vector(%u,:) =%s;\n',icons,inputs.IOCsol.control_const(icons,:));
               
                for istep=1:inputs.IOCsol.n_linear{1}
                    fprintf(fid2,'\t h(%u) =const_vector(%u,%u);\n',istep+ncount+nconstraints,icons,istep);
                end
                ncount=ncount+inputs.IOCsol.n_linear{1};
            end
            
            switch inputs.nlpsol.nlpsolver
                
                case 'de'
                    fprintf(fid2,'\n%% Death penalty for DE\n');
                    fprintf(fid2,'\nswitch inputs.nlpsol.nlpsolver\n');
                    fprintf(fid2,'\ncase ''de''\n');
                    for icons=1 :inputs.IOCsol.n_control_const* inputs.IOCsol.n_linear
                        fprintf(fid2,'\t if h(%u) >%e\n',icons+nconstraints,inputs.IOCsol.control_const_max_viol);
                        fprintf(fid2,'\t f=inf;\n');
                        fprintf(fid2,'\t end;\n');
                    end
                    fprintf(fid2,'\t end;\n');
                    
                case {'ssm','ess','eSS','fssm','local','multistart','hybrid','wsm'}
                    
                    for icons=1:inputs.IOCsol.n_control_const* inputs.IOCsol.n_linear{1}
                        fprintf(fid3,'problem.c_L(1,%u)=-inf;\n',icons+nconstraints);
                        fprintf(fid3,'problem.c_U(1,%u)=%e;\n',icons+nconstraints,inputs.IOCsol.control_const_max_viol);
                    end
                    
            end %switch inputs.nlpsol.nlpsolver
            
            
            switch inputs.nlpsol.global_solver
                case 'de'
                    fprintf(fid2,'\n%% Death penalty for DE\n');
                    fprintf(fid2,'\n switch inputs.nlpsol.global_solver\n');
                    fprintf(fid2,'\ncase ''de''\n');
                    for icons=1 :inputs.IOCsol.n_control_const* inputs.IOCsol.n_linear
                        fprintf(fid2,'\t if h(%u) >%e\n',icons+nconstraints,inputs.IOCsol.control_const_max_viol);
                        fprintf(fid2,'\t f=inf;\n');
                        fprintf(fid2,'\t end;\n');
                    end
                    fprintf(fid2,'\t end;\n');
            end
            
    end %    switch inputs.exps.u_interp{1}
    
end % if inputs.IOCsol.n_control_const>0


results.nlpsol.ntotalconstraints=nconstraints+ncount+inputs.IOCsol.n_pconst_ineq;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONSTRAINTS: POINT inequality
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

nconst=nconstraints+ncount;
if inputs.IOCsol.n_pconst_ineq>0

    fprintf(fid2,'\n%% Point inequality constraints\n');
  for i=1:inputs.model.st_names
   for j=1:inputs.IOCsol.n_pconst_ineq
   fprintf(fid2,'\ty%u_tp(%u) = y(j+1,i);\n',i,j);  
  end  
  end  
  
    for icons=1:inputs.IOCsol.n_pconst_ineq
        fprintf(fid2,'\th(%u) = %s;\n',icons+nconst,inputs.IOCsol.pconst_ineq(icons,:));
    end
    
    
    % FOR DE WE NEED TO IMPLEMENT THE DEATH PENALTY
    switch inputs.nlpsol.nlpsolver
        case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');
            fprintf(fid2,'\nswitch inputs.nlpsol.nlpsolver\n');
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1 :inputs.IOCsol.n_pconst_ineq
                fprintf(fid2,'\t if h(%u) >%e\n',icons+nconst,inputs.IOCsol.ineq_const_max_viol);
                fprintf(fid2,'\t f=inf;\n');
                fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
            
        case {'ssm','ess','eSS','fssm','local','multistart','hybrid','wsm'}
            for icons=1:inputs.IOCsol.n_pconst_ineq
                fprintf(fid3,'problem.c_L(1,%u)=-inf;\n',icons+inputs.IOCsol.n_pconst_ineq);
                fprintf(fid3,'problem.c_U(1,%u)=%e;\n',icons+inputs.IOCsol.n_pconst_ineq,inputs.IOCsol.ineq_const_max_viol);
            end
    end
    
    
    % FOR HYBRIDS WITH DE WE NEED TO IMPLEMENT THE DEATH PENALTY
    
    switch inputs.nlpsol.global_solver
        case 'de'
            fprintf(fid2,'\n%% Death penalty for DE\n');
            fprintf(fid2,'\nswitch inputs.nlpsol.global_solver\n');
            fprintf(fid2,'\ncase ''de''\n');
            for icons=1 :inputs.IOCsol.n_pconst_ineq
                fprintf(fid2,'\t if h(%u) >%e\n',icons+nconst,inputs.IOCsol.ineq_const_max_viol);
                fprintf(fid2,'\t f=inf;\n');
                fprintf(fid2,'\t end;\n');
            end
            fprintf(fid2,'\t end;\n');
    end
    
end

% if inputs.IOCsol.n_pconst_ineq==0 
%     fprintf(fid2,'\t h(1)=0;\n');
% end
  
  
 

fprintf(fid2,'\n\nreturn');
fclose(fid2);
fclose(fid3);

fprintf(1,'\n\nThe following files have been created:\n')
inputs.pathd.ioc_file
inputs.pathd.ioc_constfile



return


